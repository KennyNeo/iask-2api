项目 'iask-2api' 的结构树:
📂 iask-2api/
    📄 .env
    📄 .env.example
    📄 .gitignore
    📄 AsyncGenerator[bytes
    📄 Dockerfile
    📄 JSONResponse
    📄 StreamingResponse
    📄 Tuple[str
    📄 docker-compose.yml
    📄 main.py
    📄 nginx.conf
    📄 requirements.txt
    📄 str
    📂 app/
        📂 core/
            📄 __init__.py
            📄 config.py
        📂 providers/
            📄 __init__.py
            📄 base_provider.py
            📄 iask_provider.py
        📂 utils/
            📄 sse_utils.py
================================================================================

--- 文件路径: .env ---

# --- 文件路径: .env ---

# [自动填充] iask-2api 生产环境配置 (v1.0 - 匿名版)
# 该文件由 Genesis Protocol · Ω (Omega) 版自动生成。

# --- 安全配置 ---
# 用于保护您的 API 服务的访问密钥，请修改为您自己的复杂密钥。
API_MASTER_KEY=1

# --- 端口配置 ---
# Nginx 对外暴露的端口
NGINX_PORT=8088



--- 文件路径: .env.example ---

# --- 文件路径: .env.example ---

# ====================================================================
# iask-2api 配置文件模板 (v1.0 - 匿名版)
# ====================================================================
#
# 请将此文件重命名为 ".env" 并填入您的密钥。
# 本项目为匿名模式，无需任何 Cookie 或其他凭证！
#

# --- 核心安全配置 (必须设置) ---
# 用于保护您 API 服务的访问密钥。
API_MASTER_KEY=sk-iask-2api-default-key-please-change-me

# --- 部署配置 (可选) ---
# Nginx 对外暴露的端口
NGINX_PORT=8088



--- 文件路径: .gitignore ---

.env

--- 文件路径: AsyncGenerator[bytes ---



--- 文件路径: Dockerfile ---

# Dockerfile
# 使用官方的 Python slim 镜像作为基础
FROM python:3.11-slim-bookworm

# 设置环境变量，优化 Python 运行
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

# 设置工作目录
WORKDIR /app

# 步骤 1: 安装系统依赖，包括 Playwright 需要的库
RUN apt-get update && apt-get install -y \
    wget \
    gnupg \
    software-properties-common \
    && rm -rf /var/lib/apt/lists/*

# 步骤 2: 安装 Python 依赖
COPY requirements.txt .
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

# 步骤 3: 创建一个非 root 用户来运行应用
RUN useradd --create-home appuser

# 步骤 4: 为 appuser 安装 Playwright 浏览器
# 设置浏览器安装路径为 appuser 的 home 目录，这样 appuser 就能找到它
ENV PLAYWRIGHT_BROWSERS_PATH=/home/appuser/.cache/ms-playwright
# 以 root 身份执行安装，但文件会写入到上面指定的 appuser 目录
RUN playwright install chromium
# 安装浏览器运行所需的系统级依赖（这需要 root 权限）
RUN playwright install-deps chromium

# 步骤 5: 复制所有应用代码，并将所有权交给 appuser
COPY . .
RUN chown -R appuser:appuser /app

# 步骤 6: 切换到 appuser 用户
USER appuser

# 暴露 FastAPI 应用运行的端口
EXPOSE 8000

# 启动应用的命令
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]


--- 文件路径: JSONResponse ---



--- 文件路径: StreamingResponse ---



--- 文件路径: Tuple[str ---



--- 文件路径: docker-compose.yml ---

services:
  nginx:
    image: nginx:latest
    container_name: iask-2api-nginx
    restart: always
    ports:
      - "${NGINX_PORT:-8088}:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - app
    networks:
      - iask-net

  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: iask-2api-app
    restart: unless-stopped
    env_file:
      - .env
    networks:
      - iask-net

networks:
  iask-net:
    driver: bridge



--- 文件路径: main.py ---

# main.py
import logging
from contextlib import asynccontextmanager
from typing import Optional

from fastapi import FastAPI, Request, HTTPException, Depends, Header
from fastapi.responses import JSONResponse
import uvicorn

from app.core.config import settings
from app.providers.iask_provider import IaskProvider

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info(f"应用启动中... {settings.APP_NAME} v{settings.APP_VERSION}")
    logger.info(f"服务将在 http://localhost:{settings.NGINX_PORT} 上可用")
    yield
    logger.info("应用已关闭。")

app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    description=settings.DESCRIPTION,
    lifespan=lifespan
)

provider = IaskProvider()

async def verify_api_key(authorization: Optional[str] = Header(None)):
    if settings.API_MASTER_KEY and settings.API_MASTER_KEY != "1":
        if not authorization or "bearer" not in authorization.lower():
            raise HTTPException(status_code=401, detail="需要 Bearer Token 认证。")
        token = authorization.split(" ")[-1]
        if token != settings.API_MASTER_KEY:
            raise HTTPException(status_code=403, detail="无效的 API Key。")

@app.post("/v1/chat/completions", dependencies=[Depends(verify_api_key)])
async def chat_completions(request: Request):
    try:
        request_data = await request.json()
        return await provider.chat_completion(request_data)
    except Exception as e:
        logger.error(f"处理聊天请求时发生顶层错误: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"内部服务器错误: {str(e)}")

@app.get("/v1/models", dependencies=[Depends(verify_api_key)], response_class=JSONResponse)
async def list_models():
    return await provider.get_models()

@app.get("/", summary="根路径", response_class=JSONResponse)
def root():
    return {"message": f"欢迎来到 {settings.APP_NAME} v{settings.APP_VERSION}. 服务运行正常。"}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)


--- 文件路径: nginx.conf ---

# --- 文件路径: nginx.conf ---

worker_processes auto;

events {
    worker_connections 1024;
}

http {
    upstream iask_backend {
        # 使用 ip_hash 确保来自同一客户端的请求被转发到同一个 worker，
        # 这对于需要会话保持的场景（如 Cloudscraper 和动态会话）至关重要。
        ip_hash;
        server app:8000;
    }

    server {
        listen 80;
        server_name localhost;

        location / {
            proxy_pass http://iask_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # --- 流式传输关键修复 (Streaming Critical Fix) ---
            proxy_buffering off;
            proxy_cache off;
            proxy_set_header Connection '';
            proxy_http_version 1.1;
            chunked_transfer_encoding off;
            proxy_set_header X-Accel-Buffering no;
            proxy_read_timeout 1d; # 延长超时以支持长轮询
        }
    }
}


--- 文件路径: requirements.txt ---

# requirements.txt
fastapi
uvicorn[standard]
httpx
pydantic-settings
python-dotenv
requests
beautifulsoup4
html2text
playwright


--- 文件路径: str ---



--- 文件路径: app\core\__init__.py ---



--- 文件路径: app\core\config.py ---

# app/core/config.py
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import List, Optional, Dict

class Settings(BaseSettings):
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding='utf-8',
        extra="ignore"
    )

    APP_NAME: str = "iask-2api"
    APP_VERSION: str = "6.0.0"
    DESCRIPTION: str = "一个将 iask.ai 转换为兼容 OpenAI 格式 API 的高性能匿名代理 (真理·终章)。"

    API_MASTER_KEY: Optional[str] = None
    
    API_REQUEST_TIMEOUT: int = 180
    NGINX_PORT: int = 8088

    # --- 模型配置 ---
    DEFAULT_MODEL: str = "通用问答 (适合日常问题)"
    
    # 模型详细信息字典
    MODEL_DETAILS: Dict[str, Dict[str, str]] = {
        "question": {
            "display_id": "通用问答 (适合日常问题)",
            "description": "适用于各种日常问题和知识查询，提供快速、准确的答案。"
        },
        "academic": {
            "display_id": "学术研究 (适合深度分析)",
            "description": "专注于学术领域的深度分析，适合论文写作、文献综述和专业知识探索。"
        },
        "thinking": {
            "display_id": "深度思考 (适合复杂推理)",
            "description": "模拟人类的深度思考过程，逐步分解问题，适合复杂逻辑推理和决策。"
        },
        "forums": {
            "display_id": "论坛观点 (适合多方视角)",
            "description": "聚合和提炼各大论坛社区的讨论观点，提供多元化的参考信息和公众意见。"
        },
        "wiki": {
            "display_id": "维基百科 (适合事实查询)",
            "description": "基于维基百科等知识库，提供高度结构化、准确的事实信息和历史背景。"
        }
    }

    # 从 MODEL_DETAILS 动态生成模型列表
    @property
    def KNOWN_MODELS(self) -> List[str]:
        return list(self.MODEL_DETAILS.keys())

    # 创建从友好ID到原始ID的映射，用于内部转换
    @property
    def DISPLAY_ID_TO_SIMPLE_ID(self) -> Dict[str, str]:
        return {details["display_id"]: simple_id for simple_id, details in self.MODEL_DETAILS.items()}

settings = Settings()


--- 文件路径: app\providers\__init__.py ---



--- 文件路径: app\providers\base_provider.py ---

# --- 文件路径: app/providers/base_provider.py ---

from abc import ABC, abstractmethod
from typing import Union
from fastapi import Request
from fastapi.responses import StreamingResponse, JSONResponse

class BaseProvider(ABC):
    @abstractmethod
    async def chat_completion(
        self,
        request: Request
    ) -> Union[StreamingResponse, JSONResponse]:
        """
        处理聊天补全请求。
        接收完整的 Request 对象以访问所有需要的信息。
        """
        pass

    @abstractmethod
    async def get_models(self) -> JSONResponse:
        """
        获取模型列表。
        """
        pass



--- 文件路径: app\providers\iask_provider.py ---

# app/providers/iask_provider.py
import logging
import uuid
import asyncio
import json
import re
from typing import Dict, Any, AsyncGenerator
from urllib.parse import urlencode

from playwright.async_api import async_playwright, Page
from fastapi.responses import StreamingResponse
import html2text

from app.core.config import settings
from app.providers.base_provider import BaseProvider
from app.utils.sse_utils import create_sse_data, create_chat_completion_chunk, DONE_CHUNK

# 配置日志
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class IaskProvider(BaseProvider):
    """
    iAsk.ai 的内容提供者。
    使用 Playwright 实现干净的、字符级增量流式响应。
    """
    def __init__(self):
        # --- 可配置参数 ---
        self.max_retries = 3           # 最大重试次数
        self.retry_delay = 5           # 重试间隔（秒）
        self.total_timeout = 180       # 总超时时间（秒）
        self.stale_timeout = 15        # 内容静止超时时间（秒）
        self.poll_interval = 0.2       # 轮询间隔（秒）
        
        # --- 内容清理正则表达式 ---
        # 匹配并移除开头的 "According to www.iAsk.Ai - Ask AI:"
        self.intro_pattern = re.compile(r'^According to www\.iAsk\.Ai - Ask AI:\s*', re.IGNORECASE)
        # 匹配并移除思考前缀
        self.thinking_pattern = re.compile(r'^(思考|Thinking)[:：]\s*', re.IGNORECASE)
        # 匹配并移除结尾的版权信息
        self.copyright_pattern = re.compile(r'\s*Answer Provided by.*?Ask AI\.?\s*$', re.IGNORECASE | re.DOTALL)
        
        # 【格式化核心】
        # 1. 确保引用标记前后有空格
        self.citation_space_pattern = re.compile(r'(\S)(\[\d+\])')
        # 2. 智能段落分隔：在引用标记后跟一个大写字母开头的新句子时，插入换行
        # 【修复点】将中文引号替换为标准英文引号，避免编码问题
        self.paragraph_pattern = re.compile(r'(\]\.\s+)(["\']?[\u4e00-\u9fffA-Z])')
        # 3. 清理多余的换行符，保留最多两个连续换行
        self.newline_pattern = re.compile(r'\n{3,}')

        logger.info("IaskProvider (Playwright-based with Ultimate Clean Streaming) 已初始化。")

        # --- 精细配置 html2text ---
        self.h = html2text.HTML2Text()
        self.h.ignore_links = False
        self.h.ignore_images = False
        self.h.ignore_emphasis = False
        self.h.body_width = 0  # 不自动换行
        self.h.protect_links = True # 保护链接不被意外断开
        self.h.wrap_links = False
        self.h.skip_internal_links = True
        self.h.inline_links = True
        self.h.images_to_alt = False # 保留图片链接，而不是只替换为alt文本
        self.h.unicode_snob = True # 使用Unicode字符

    def _clean_text_chunk(self, text_chunk: str) -> str:
        """
        使用正则表达式清理文本片段，移除引导语、版权信息、思考前缀，并优化格式。
        """
        # 1. 移除开头的引导语
        cleaned_chunk = self.intro_pattern.sub('', text_chunk)
        # 2. 移除思考前缀
        cleaned_chunk = self.thinking_pattern.sub('', cleaned_chunk)
        # 3. 移除结尾的版权信息
        cleaned_chunk = self.copyright_pattern.sub('', cleaned_chunk)
        
        # 4. 格式优化
        # 确保引用标记前后有空格
        cleaned_chunk = self.citation_space_pattern.sub(r'\1 \2', cleaned_chunk)
        # 智能段落分隔
        cleaned_chunk = self.paragraph_pattern.sub(r'\1\n\n\2', cleaned_chunk)
        # 清理多余的换行符
        cleaned_chunk = self.newline_pattern.sub('\n\n', cleaned_chunk)
        
        # 5. 去除首尾可能的空白
        return cleaned_chunk.strip()

    async def stream_answer(self, prompt: str, model: str) -> AsyncGenerator[str, None]:
        params = {
            'q': prompt,
            'mode': model,
            'options[detail_level]': 'comprehensive',
            'source': 'organic'
        }
        initial_url = f"https://iask.ai/q?{urlencode(params)}"
        
        logger.info(f"步骤 1: 使用Playwright开始流式访问 URL: {initial_url}")

        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=True)
            page = await browser.new_page()
            
            try:
                await page.goto(initial_url)
                await page.wait_for_selector('#text', timeout=20000)
                logger.info("答案容器 (#text) 已出现，开始字符级增量流式监听...")

                # --- “双保险”结束策略 ---
                async def wait_for_related_questions():
                    try:
                        await page.wait_for_selector('#relatedQuestions', timeout=self.total_timeout * 1000)
                        return True
                    except Exception:
                        return False
                
                completion_task = asyncio.create_task(wait_for_related_questions())

                # 主循环：字符级增量流式读取
                last_full_text = ""
                no_change_timer = 0
                total_timer = 0
                
                while not completion_task.done() and no_change_timer < self.stale_timeout and total_timer < self.total_timeout:
                    try:
                        await asyncio.sleep(self.poll_interval)
                        total_timer += self.poll_interval

                        # 1. 获取当前全部HTML并转换为全部文本
                        current_html = await page.inner_html('#text')
                        current_full_text = self.h.handle(current_html).strip()
                        
                        # 2. 计算新增的文本（增量部分）
                        if len(current_full_text) > len(last_full_text):
                            # 有新内容，重置静止计时器
                            no_change_timer = 0
                            new_text_chunk = current_full_text[len(last_full_text):]
                            last_full_text = current_full_text
                            
                            # 3. 清理文本片段
                            cleaned_chunk = self._clean_text_chunk(new_text_chunk)
                            
                            if cleaned_chunk:
                                logger.info(f"流式发送片段，长度: {len(cleaned_chunk)}")
                                yield cleaned_chunk
                        else:
                            # 内容无变化，增加静止计时器
                            no_change_timer += self.poll_interval
                            logger.info(f"内容无变化，静止计时: {no_change_timer:.1f}s / {self.stale_timeout}s")

                    except Exception as e:
                        logger.error(f"流式读取内容时出错: {e}")
                        yield f"\n\n错误：{e}"
                        break
                
                # --- 循环结束，判断原因 ---
                if completion_task.done() and completion_task.result():
                    logger.info("流式结束原因：检测到 'People Also Ask' 区域，答案已完全生成。")
                elif no_change_timer >= self.stale_timeout:
                    logger.info(f"流式结束原因：内容已静止超过 {self.stale_timeout} 秒。")
                elif total_timer >= self.total_timeout:
                    logger.warning(f"流式结束原因：达到总超时时间 {self.total_timeout} 秒。")
                else:
                    logger.warning("流式结束原因：未知异常。")

                # 最后再检查一次，确保没有遗漏
                final_html = await page.inner_html('#text')
                final_full_text = self.h.handle(final_html).strip()
                if len(final_full_text) > len(last_full_text):
                    final_chunk = final_full_text[len(last_full_text):]
                    cleaned_final_chunk = self._clean_text_chunk(final_chunk)
                    if cleaned_final_chunk:
                        yield cleaned_final_chunk

            except Exception as e:
                logger.error(f"流式处理流程中发生顶层错误: {e}", exc_info=True)
                yield f"错误：{e}"
            finally:
                await browser.close()

    async def chat_completion(self, request_data: Dict[str, Any]) -> StreamingResponse:
        async def stream_generator() -> AsyncGenerator[bytes, None]:
            request_id = f"chatcmpl-{uuid.uuid4()}"
            # 从请求中获取模型名称（可能是友好ID）
            model_name_from_request = request_data.get("model", settings.DEFAULT_MODEL)
            
            # 【修复点】将友好ID转换为原始ID，并设置一个安全的回退值
            # 如果找不到请求中的模型，则回退到配置文件中设置的默认模型的原始ID
            default_simple_model = settings.DISPLAY_ID_TO_SIMPLE_ID.get(settings.DEFAULT_MODEL)
            simple_model_name = settings.DISPLAY_ID_TO_SIMPLE_ID.get(model_name_from_request, default_simple_model)
            
            logger.info(f"接收到模型 '{model_name_from_request}'，已转换为内部ID '{simple_model_name}'")

            question = request_data["messages"][-1]["content"]
            
            try:
                async for markdown_chunk in self.stream_answer(question, simple_model_name):
                    chunk = create_chat_completion_chunk(request_id, model_name_from_request, markdown_chunk)
                    yield create_sse_data(chunk)
                
            except Exception as e:
                logger.error(f"处理流程中发生顶层错误: {e}", exc_info=True)
                error_message = f"获取答案失败: {e}"
                error_chunk = create_chat_completion_chunk(request_id, model_name_from_request, error_message, "stop")
                yield create_sse_data(error_chunk)
            finally:
                yield DONE_CHUNK

        return StreamingResponse(stream_generator(), media_type="text/event-stream")

    async def get_models(self) -> Dict[str, Any]:
        import time
        return {
            "object": "list",
            "data": [
                {
                    "id": details["display_id"],
                    "object": "model",
                    "created": int(time.time()),
                    "owned_by": "iask-2api"
                }
                for details in settings.MODEL_DETAILS.values()
            ]
        }


--- 文件路径: app\utils\sse_utils.py ---

# --- 文件路径: app/utils/sse_utils.py ---

import json
import time
from typing import Dict, Any, Optional

DONE_CHUNK = b"data: [DONE]\n\n"

def create_sse_data(data: Dict[str, Any]) -> bytes:
    """将字典编码为 SSE data 行，确保非 ASCII 字符正确处理。"""
    return f"data: {json.dumps(data, ensure_ascii=False)}\n\n".encode('utf-8')

def create_chat_completion_chunk(
    request_id: str,
    model: str,
    content: str,
    finish_reason: Optional[str] = None
) -> Dict[str, Any]:
    """为增量流（delta）创建标准的 OpenAI 格式数据块。"""
    return {
        "id": request_id,
        "object": "chat.completion.chunk",
        "created": int(time.time()),
        "model": model,
        "choices": [
            {
                "index": 0,
                "delta": {"content": content} if content is not None else {},
                "finish_reason": finish_reason,
                "logprobs": None,
            }
        ],
    }



